/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.1.0 (NJsonSchema v10.3.3.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class VideoClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:44333';
  }

  get(filename: string | null): Observable<FileResponse | null> {
    let url_ = this.baseUrl + '/api/Video/{filename}';
    if (filename === undefined || filename === null) throw new Error("The parameter 'filename' must be defined.");
    url_ = url_.replace('{filename}', encodeURIComponent('' + filename));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<FileResponse | null>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse | null>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse | null>(<any>null);
  }
}

@Injectable()
export class ViewMeetingClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:44333';
  }

  get(meetingId: number): Observable<ViewMeeting_Dto> {
    let url_ = this.baseUrl + '/api/ViewMeeting/{meetingId}';
    if (meetingId === undefined || meetingId === null) throw new Error("The parameter 'meetingId' must be defined.");
    url_ = url_.replace('{meetingId}', encodeURIComponent('' + meetingId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ViewMeeting_Dto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ViewMeeting_Dto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ViewMeeting_Dto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ViewMeeting_Dto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ViewMeeting_Dto>(<any>null);
  }

  put(
    meetingId: number,
    meetingId: number | undefined,
    govbodyName: string | null | undefined,
    locationName: string | null | undefined,
    date: string | null | undefined,
    topics: ViewMeetingTopic_Dto[] | null | undefined,
    speakers: ViewMeetingSpeaker_Dto[] | null | undefined,
    sections: ViewMeetingSection_Dto[] | null | undefined
  ): Observable<boolean> {
    let url_ = this.baseUrl + '/api/ViewMeeting/{meetingId}?';
    if (meetingId === undefined || meetingId === null) throw new Error("The parameter 'meetingId' must be defined.");
    url_ = url_.replace('{meetingId}', encodeURIComponent('' + meetingId));
    if (meetingId === null) throw new Error("The parameter 'meetingId' cannot be null.");
    else if (meetingId !== undefined) url_ += 'MeetingId=' + encodeURIComponent('' + meetingId) + '&';
    if (govbodyName !== undefined && govbodyName !== null)
      url_ += 'GovbodyName=' + encodeURIComponent('' + govbodyName) + '&';
    if (locationName !== undefined && locationName !== null)
      url_ += 'LocationName=' + encodeURIComponent('' + locationName) + '&';
    if (date !== undefined && date !== null) url_ += 'Date=' + encodeURIComponent('' + date) + '&';
    if (topics !== undefined && topics !== null)
      topics &&
        topics.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'Topics[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (speakers !== undefined && speakers !== null)
      speakers &&
        speakers.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'Speakers[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (sections !== undefined && sections !== null)
      sections &&
        sections.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'Sections[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }
}

@Injectable()
export class EditMeetingClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:44333';
  }

  get(meetingId: number, part: number): Observable<EditMeeting_Dto> {
    let url_ = this.baseUrl + '/api/EditMeeting/{meetingId}/{part}';
    if (meetingId === undefined || meetingId === null) throw new Error("The parameter 'meetingId' must be defined.");
    url_ = url_.replace('{meetingId}', encodeURIComponent('' + meetingId));
    if (part === undefined || part === null) throw new Error("The parameter 'part' must be defined.");
    url_ = url_.replace('{part}', encodeURIComponent('' + part));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EditMeeting_Dto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EditMeeting_Dto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EditMeeting_Dto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EditMeeting_Dto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EditMeeting_Dto>(<any>null);
  }

  post(value: EditMeeting_Dto, meetingId: number, part: number): Observable<boolean> {
    let url_ = this.baseUrl + '/api/EditMeeting/{meetingId}/{part}';
    if (meetingId === undefined || meetingId === null) throw new Error("The parameter 'meetingId' must be defined.");
    url_ = url_.replace('{meetingId}', encodeURIComponent('' + meetingId));
    if (part === undefined || part === null) throw new Error("The parameter 'part' must be defined.");
    url_ = url_.replace('{part}', encodeURIComponent('' + part));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(value);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }
}

@Injectable()
export class HealthCheckClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:44333';
  }

  /**
   * Get server status
   * @param testId Send any interger.
   * @return It should return the integer times 2.
   */
  get(testId: number): Observable<string> {
    let url_ = this.baseUrl + '/api/HealthCheck/{testId}';
    if (testId === undefined || testId === null) throw new Error("The parameter 'testId' must be defined.");
    url_ = url_.replace('{testId}', encodeURIComponent('' + testId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  getWeather(): Observable<WeatherForecast[]> {
    let url_ = this.baseUrl + '/api/HealthCheck';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetWeather(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetWeather(<any>response_);
            } catch (e) {
              return <Observable<WeatherForecast[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<WeatherForecast[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetWeather(response: HttpResponseBase): Observable<WeatherForecast[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(WeatherForecast.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<WeatherForecast[]>(<any>null);
  }
}

@Injectable()
export class GovLocationClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:44333';
  }

  /**
   * Register GovLocation
   * @return Id of new GovLocation
   */
  register(command: RegisterGovLocation_Cmd): Observable<number> {
    let url_ = this.baseUrl + '/api/GovLocation/Register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  /**
   * Get GovLocations for current user
   * @return List of current user's GovLocations
   */
  getMyGovLocations(): Observable<GovLocation_Dto[]> {
    let url_ = this.baseUrl + '/api/GovLocation/GetMyGovLocations';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMyGovLocations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMyGovLocations(<any>response_);
            } catch (e) {
              return <Observable<GovLocation_Dto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GovLocation_Dto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMyGovLocations(response: HttpResponseBase): Observable<GovLocation_Dto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GovLocation_Dto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GovLocation_Dto[]>(<any>null);
  }
}

@Injectable()
export class GovbodyClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:44333';
  }

  /**
   * Register Govbody (or update registration)
   */
  register(command: RegisterGovbody_Cmd): Observable<number> {
    let url_ = this.baseUrl + '/api/Govbody/Register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  /**
   * Get Govbodies for a GovLocation
   * @param id GovLocation Id
   */
  getGovbodies(id: number): Observable<Govbody_Dto[]> {
    let url_ = this.baseUrl + '/api/Govbody/GetGovbodies/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGovbodies(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGovbodies(<any>response_);
            } catch (e) {
              return <Observable<Govbody_Dto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<Govbody_Dto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGovbodies(response: HttpResponseBase): Observable<Govbody_Dto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(Govbody_Dto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<Govbody_Dto[]>(<any>null);
  }

  /**
   * Get Govbody by Id
   * @param id Govbody Id
   */
  getGovbody(id: number): Observable<GovbodyDetails_Dto> {
    let url_ = this.baseUrl + '/api/Govbody/GetGovbody/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGovbody(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGovbody(<any>response_);
            } catch (e) {
              return <Observable<GovbodyDetails_Dto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GovbodyDetails_Dto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGovbody(response: HttpResponseBase): Observable<GovbodyDetails_Dto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GovbodyDetails_Dto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GovbodyDetails_Dto>(<any>null);
  }
}

@Injectable()
export class WeatherForecastClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:44333';
  }

  get(): Observable<WeatherForecast2[]> {
    let url_ = this.baseUrl + '/WeatherForecast';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<WeatherForecast2[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<WeatherForecast2[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<WeatherForecast2[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(WeatherForecast2.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<WeatherForecast2[]>(<any>null);
  }
}

export class ViewMeeting_Dto implements IViewMeeting_Dto {
  meetingId!: number;
  govbodyName?: string | undefined;
  locationName?: string | undefined;
  date?: string | undefined;
  topics?: ViewMeetingTopic_Dto[] | undefined;
  speakers?: ViewMeetingSpeaker_Dto[] | undefined;
  sections?: ViewMeetingSection_Dto[] | undefined;

  constructor(data?: IViewMeeting_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.meetingId = _data['meetingId'];
      this.govbodyName = _data['govbodyName'];
      this.locationName = _data['locationName'];
      this.date = _data['date'];
      if (Array.isArray(_data['topics'])) {
        this.topics = [] as any;
        for (let item of _data['topics']) this.topics!.push(ViewMeetingTopic_Dto.fromJS(item));
      }
      if (Array.isArray(_data['speakers'])) {
        this.speakers = [] as any;
        for (let item of _data['speakers']) this.speakers!.push(ViewMeetingSpeaker_Dto.fromJS(item));
      }
      if (Array.isArray(_data['sections'])) {
        this.sections = [] as any;
        for (let item of _data['sections']) this.sections!.push(ViewMeetingSection_Dto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ViewMeeting_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new ViewMeeting_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['meetingId'] = this.meetingId;
    data['govbodyName'] = this.govbodyName;
    data['locationName'] = this.locationName;
    data['date'] = this.date;
    if (Array.isArray(this.topics)) {
      data['topics'] = [];
      for (let item of this.topics) data['topics'].push(item.toJSON());
    }
    if (Array.isArray(this.speakers)) {
      data['speakers'] = [];
      for (let item of this.speakers) data['speakers'].push(item.toJSON());
    }
    if (Array.isArray(this.sections)) {
      data['sections'] = [];
      for (let item of this.sections) data['sections'].push(item.toJSON());
    }
    return data;
  }
}

export interface IViewMeeting_Dto {
  meetingId: number;
  govbodyName?: string | undefined;
  locationName?: string | undefined;
  date?: string | undefined;
  topics?: ViewMeetingTopic_Dto[] | undefined;
  speakers?: ViewMeetingSpeaker_Dto[] | undefined;
  sections?: ViewMeetingSection_Dto[] | undefined;
}

export class ViewMeetingTopic_Dto implements IViewMeetingTopic_Dto {
  topicId!: number;
  name?: string | undefined;
  isExisting!: boolean;

  constructor(data?: IViewMeetingTopic_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.topicId = _data['topicId'];
      this.name = _data['name'];
      this.isExisting = _data['isExisting'];
    }
  }

  static fromJS(data: any): ViewMeetingTopic_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new ViewMeetingTopic_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['topicId'] = this.topicId;
    data['name'] = this.name;
    data['isExisting'] = this.isExisting;
    return data;
  }
}

export interface IViewMeetingTopic_Dto {
  topicId: number;
  name?: string | undefined;
  isExisting: boolean;
}

export class ViewMeetingSpeaker_Dto implements IViewMeetingSpeaker_Dto {
  speakerId!: number;
  name?: string | undefined;
  isExisting!: boolean;

  constructor(data?: IViewMeetingSpeaker_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.speakerId = _data['speakerId'];
      this.name = _data['name'];
      this.isExisting = _data['isExisting'];
    }
  }

  static fromJS(data: any): ViewMeetingSpeaker_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new ViewMeetingSpeaker_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['speakerId'] = this.speakerId;
    data['name'] = this.name;
    data['isExisting'] = this.isExisting;
    return data;
  }
}

export interface IViewMeetingSpeaker_Dto {
  speakerId: number;
  name?: string | undefined;
  isExisting: boolean;
}

export class ViewMeetingSection_Dto implements IViewMeetingSection_Dto {
  name?: string | undefined;
  topicDiscussions?: ViewMeetingTopicDiscussion_Dto[] | undefined;

  constructor(data?: IViewMeetingSection_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      if (Array.isArray(_data['topicDiscussions'])) {
        this.topicDiscussions = [] as any;
        for (let item of _data['topicDiscussions'])
          this.topicDiscussions!.push(ViewMeetingTopicDiscussion_Dto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ViewMeetingSection_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new ViewMeetingSection_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (Array.isArray(this.topicDiscussions)) {
      data['topicDiscussions'] = [];
      for (let item of this.topicDiscussions) data['topicDiscussions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IViewMeetingSection_Dto {
  name?: string | undefined;
  topicDiscussions?: ViewMeetingTopicDiscussion_Dto[] | undefined;
}

export class ViewMeetingTopicDiscussion_Dto implements IViewMeetingTopicDiscussion_Dto {
  topicId!: number;
  talks?: ViewMeetingTalk_Dto[] | undefined;

  constructor(data?: IViewMeetingTopicDiscussion_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.topicId = _data['topicId'];
      if (Array.isArray(_data['talks'])) {
        this.talks = [] as any;
        for (let item of _data['talks']) this.talks!.push(ViewMeetingTalk_Dto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ViewMeetingTopicDiscussion_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new ViewMeetingTopicDiscussion_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['topicId'] = this.topicId;
    if (Array.isArray(this.talks)) {
      data['talks'] = [];
      for (let item of this.talks) data['talks'].push(item.toJSON());
    }
    return data;
  }
}

export interface IViewMeetingTopicDiscussion_Dto {
  topicId: number;
  talks?: ViewMeetingTalk_Dto[] | undefined;
}

export class ViewMeetingTalk_Dto implements IViewMeetingTalk_Dto {
  speakerId!: number;
  text?: string | undefined;

  constructor(data?: IViewMeetingTalk_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.speakerId = _data['speakerId'];
      this.text = _data['text'];
    }
  }

  static fromJS(data: any): ViewMeetingTalk_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new ViewMeetingTalk_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['speakerId'] = this.speakerId;
    data['text'] = this.text;
    return data;
  }
}

export interface IViewMeetingTalk_Dto {
  speakerId: number;
  text?: string | undefined;
}

export class EditMeeting_Dto implements IEditMeeting_Dto {
  sections?: string[] | undefined;
  topics?: string[] | undefined;
  talks?: EditMeetingTalk_Dto[] | undefined;
  lastEdit!: number;

  constructor(data?: IEditMeeting_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['sections'])) {
        this.sections = [] as any;
        for (let item of _data['sections']) this.sections!.push(item);
      }
      if (Array.isArray(_data['topics'])) {
        this.topics = [] as any;
        for (let item of _data['topics']) this.topics!.push(item);
      }
      if (Array.isArray(_data['talks'])) {
        this.talks = [] as any;
        for (let item of _data['talks']) this.talks!.push(EditMeetingTalk_Dto.fromJS(item));
      }
      this.lastEdit = _data['lastEdit'];
    }
  }

  static fromJS(data: any): EditMeeting_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new EditMeeting_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.sections)) {
      data['sections'] = [];
      for (let item of this.sections) data['sections'].push(item);
    }
    if (Array.isArray(this.topics)) {
      data['topics'] = [];
      for (let item of this.topics) data['topics'].push(item);
    }
    if (Array.isArray(this.talks)) {
      data['talks'] = [];
      for (let item of this.talks) data['talks'].push(item.toJSON());
    }
    data['lastEdit'] = this.lastEdit;
    return data;
  }
}

export interface IEditMeeting_Dto {
  sections?: string[] | undefined;
  topics?: string[] | undefined;
  talks?: EditMeetingTalk_Dto[] | undefined;
  lastEdit: number;
}

export class EditMeetingTalk_Dto implements IEditMeetingTalk_Dto {
  transcript?: string | undefined;
  confidence!: number;
  wordCount!: number;
  speakerName?: string | undefined;
  sectionName?: string | undefined;
  topicName?: string | undefined;
  showSetTopic!: boolean;
  words?: EditMeetingWord_Dto[] | undefined;

  constructor(data?: IEditMeetingTalk_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.transcript = _data['transcript'];
      this.confidence = _data['confidence'];
      this.wordCount = _data['wordCount'];
      this.speakerName = _data['speakerName'];
      this.sectionName = _data['sectionName'];
      this.topicName = _data['topicName'];
      this.showSetTopic = _data['showSetTopic'];
      if (Array.isArray(_data['words'])) {
        this.words = [] as any;
        for (let item of _data['words']) this.words!.push(EditMeetingWord_Dto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EditMeetingTalk_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new EditMeetingTalk_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['transcript'] = this.transcript;
    data['confidence'] = this.confidence;
    data['wordCount'] = this.wordCount;
    data['speakerName'] = this.speakerName;
    data['sectionName'] = this.sectionName;
    data['topicName'] = this.topicName;
    data['showSetTopic'] = this.showSetTopic;
    if (Array.isArray(this.words)) {
      data['words'] = [];
      for (let item of this.words) data['words'].push(item.toJSON());
    }
    return data;
  }
}

export interface IEditMeetingTalk_Dto {
  transcript?: string | undefined;
  confidence: number;
  wordCount: number;
  speakerName?: string | undefined;
  sectionName?: string | undefined;
  topicName?: string | undefined;
  showSetTopic: boolean;
  words?: EditMeetingWord_Dto[] | undefined;
}

export class EditMeetingWord_Dto implements IEditMeetingWord_Dto {
  word?: string | undefined;
  confidence!: number;
  startTime!: number;
  endTime!: number;
  wordNum!: number;
  speakerTag!: number;

  constructor(data?: IEditMeetingWord_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.word = _data['word'];
      this.confidence = _data['confidence'];
      this.startTime = _data['startTime'];
      this.endTime = _data['endTime'];
      this.wordNum = _data['wordNum'];
      this.speakerTag = _data['speakerTag'];
    }
  }

  static fromJS(data: any): EditMeetingWord_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new EditMeetingWord_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['word'] = this.word;
    data['confidence'] = this.confidence;
    data['startTime'] = this.startTime;
    data['endTime'] = this.endTime;
    data['wordNum'] = this.wordNum;
    data['speakerTag'] = this.speakerTag;
    return data;
  }
}

export interface IEditMeetingWord_Dto {
  word?: string | undefined;
  confidence: number;
  startTime: number;
  endTime: number;
  wordNum: number;
  speakerTag: number;
}

export class WeatherForecast implements IWeatherForecast {
  date!: Date;
  temperatureC!: number;
  temperatureF!: number;
  summary?: string | undefined;

  constructor(data?: IWeatherForecast) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.temperatureC = _data['temperatureC'];
      this.temperatureF = _data['temperatureF'];
      this.summary = _data['summary'];
    }
  }

  static fromJS(data: any): WeatherForecast {
    data = typeof data === 'object' ? data : {};
    let result = new WeatherForecast();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['temperatureC'] = this.temperatureC;
    data['temperatureF'] = this.temperatureF;
    data['summary'] = this.summary;
    return data;
  }
}

export interface IWeatherForecast {
  date: Date;
  temperatureC: number;
  temperatureF: number;
  summary?: string | undefined;
}

export class GovLocation_Dto implements IGovLocation_Dto {
  id!: number;
  name?: string | undefined;
  type!: GovlocTypes;
  parentLocationId!: number;

  constructor(data?: IGovLocation_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.type = _data['type'];
      this.parentLocationId = _data['parentLocationId'];
    }
  }

  static fromJS(data: any): GovLocation_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new GovLocation_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['type'] = this.type;
    data['parentLocationId'] = this.parentLocationId;
    return data;
  }
}

export interface IGovLocation_Dto {
  id: number;
  name?: string | undefined;
  type: GovlocTypes;
  parentLocationId: number;
}

export class RegisterGovLocation_Cmd extends GovLocation_Dto implements IRegisterGovLocation_Cmd {
  constructor(data?: IRegisterGovLocation_Cmd) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): RegisterGovLocation_Cmd {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterGovLocation_Cmd();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IRegisterGovLocation_Cmd extends IGovLocation_Dto {}

export enum GovlocTypes {
  City = 0,
  Town = 1,
  Borough = 2,
  Township = 3,
  County = 4,
  StateOrProvince = 5,
  Territory = 6,
  Country = 7,
}

export class GovbodyDetails_Dto implements IGovbodyDetails_Dto {
  name?: string | undefined;
  parentLocationId!: number;
  electedOfficials?: ElectedOfficial_Dto[] | undefined;
  appointedOfficials?: AppointedOfficial_Dto[] | undefined;
  recordingsUrl?: string | undefined;
  transcriptsUrl?: string | undefined;

  constructor(data?: IGovbodyDetails_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.parentLocationId = _data['parentLocationId'];
      if (Array.isArray(_data['electedOfficials'])) {
        this.electedOfficials = [] as any;
        for (let item of _data['electedOfficials']) this.electedOfficials!.push(ElectedOfficial_Dto.fromJS(item));
      }
      if (Array.isArray(_data['appointedOfficials'])) {
        this.appointedOfficials = [] as any;
        for (let item of _data['appointedOfficials']) this.appointedOfficials!.push(AppointedOfficial_Dto.fromJS(item));
      }
      this.recordingsUrl = _data['recordingsUrl'];
      this.transcriptsUrl = _data['transcriptsUrl'];
    }
  }

  static fromJS(data: any): GovbodyDetails_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new GovbodyDetails_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['parentLocationId'] = this.parentLocationId;
    if (Array.isArray(this.electedOfficials)) {
      data['electedOfficials'] = [];
      for (let item of this.electedOfficials) data['electedOfficials'].push(item.toJSON());
    }
    if (Array.isArray(this.appointedOfficials)) {
      data['appointedOfficials'] = [];
      for (let item of this.appointedOfficials) data['appointedOfficials'].push(item.toJSON());
    }
    data['recordingsUrl'] = this.recordingsUrl;
    data['transcriptsUrl'] = this.transcriptsUrl;
    return data;
  }
}

export interface IGovbodyDetails_Dto {
  name?: string | undefined;
  parentLocationId: number;
  electedOfficials?: ElectedOfficial_Dto[] | undefined;
  appointedOfficials?: AppointedOfficial_Dto[] | undefined;
  recordingsUrl?: string | undefined;
  transcriptsUrl?: string | undefined;
}

export class RegisterGovbody_Cmd extends GovbodyDetails_Dto implements IRegisterGovbody_Cmd {
  constructor(data?: IRegisterGovbody_Cmd) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): RegisterGovbody_Cmd {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterGovbody_Cmd();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IRegisterGovbody_Cmd extends IGovbodyDetails_Dto {}

export class Official_Dto implements IOfficial_Dto {
  name?: string | undefined;
  title?: string | undefined;

  constructor(data?: IOfficial_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): Official_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new Official_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['title'] = this.title;
    return data;
  }
}

export interface IOfficial_Dto {
  name?: string | undefined;
  title?: string | undefined;
}

export class ElectedOfficial_Dto extends Official_Dto implements IElectedOfficial_Dto {
  constructor(data?: IElectedOfficial_Dto) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): ElectedOfficial_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new ElectedOfficial_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IElectedOfficial_Dto extends IOfficial_Dto {}

export class AppointedOfficial_Dto extends Official_Dto implements IAppointedOfficial_Dto {
  constructor(data?: IAppointedOfficial_Dto) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): AppointedOfficial_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new AppointedOfficial_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IAppointedOfficial_Dto extends IOfficial_Dto {}

export class Govbody_Dto implements IGovbody_Dto {
  name?: string | undefined;
  parentLocationId!: number;

  constructor(data?: IGovbody_Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.parentLocationId = _data['parentLocationId'];
    }
  }

  static fromJS(data: any): Govbody_Dto {
    data = typeof data === 'object' ? data : {};
    let result = new Govbody_Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['parentLocationId'] = this.parentLocationId;
    return data;
  }
}

export interface IGovbody_Dto {
  name?: string | undefined;
  parentLocationId: number;
}

export class WeatherForecast2 implements IWeatherForecast2 {
  date!: Date;
  temperatureC!: number;
  temperatureF!: number;
  summary?: string | undefined;

  constructor(data?: IWeatherForecast2) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.temperatureC = _data['temperatureC'];
      this.temperatureF = _data['temperatureF'];
      this.summary = _data['summary'];
    }
  }

  static fromJS(data: any): WeatherForecast2 {
    data = typeof data === 'object' ? data : {};
    let result = new WeatherForecast2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['temperatureC'] = this.temperatureC;
    data['temperatureF'] = this.temperatureF;
    data['summary'] = this.summary;
    return data;
  }
}

export interface IWeatherForecast2 {
  date: Date;
  temperatureC: number;
  temperatureF: number;
  summary?: string | undefined;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
